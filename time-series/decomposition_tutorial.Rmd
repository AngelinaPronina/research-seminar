---
title: "Исследование структуры временных рядов в R (практика)"
author: "Заходякин Г.В., postlogist@gmail.com"
output: 
  html_document: 
    number_sections: no
    toc: yes
    toc_depth: 2
---


# Введение

В этом блокноте разобран пример анализа регулярного временного ряда из базы данных ВШЭ Sophist с использованием метода классической декомпозиции (базовый R) и STL-декомпозиции (пакет `forecast`).


```{r Подключение библиотек, message=FALSE, warning=FALSE}
library(tidyverse) # ggplot2 и трансформация данных
library(forecast) # анализ временных рядов и прогнозирование
library(sophisthse) # Загрузка временных рядов из базы Sophist
library(stringr)  # Работа с текстовыми строками
```


# Как загрузить данные из Sophist

Для автоматической загрузки данных из БД Sophist можно использовать пакет [`sophisthse`](https://CRAN.R-project.org/package=sophisthse), разработанный Борисом Демешевым.
В дистрибутив для курса этот пакет включен. Если вы самостоятельно устанавливали R, то убедитесь в том, что у вас этот пакет установлен. Как обычно, пакет из CRAN можно установить командой `install.packages()`.

Главная функция пакета - `sophisthse()` - загружает многомерные временные ряды, т.е. таблицы. Чтобы загрузить временной ряд, надо знать название соответствующего показателя. Вы можете узнать имена показателей в самой базе данных - см. http://sophist.hse.ru/hse/nindex.shtml.

Например, открыв таблицу http://sophist.hse.ru/exes/tables/RTRD_M_I.htm, можно узнать, что показатель:  `Оборот розничной торговли в текущих ценах` называется `RTRD_M`.

Другой способ - просмотр встроенного в пакет списка показателей (`series_info`)


```{r Список показателей в пакете sophisthse}
head(series_info, n = 10)
```

Заметим, что название показателя для загрузки содержится в столбце `tsname`, а расшифровка - в столбце `fullname`.

Можно искать показатель в таблице, используя поиск по шаблону строки (`stringr::str_detect()`). В простейшем случае шаблон - это искомая подстрока. Более сложные шаблоны (регулярные выражения) описаны в книге [R for data science](http://r4ds.had.co.nz/strings.html) - см. раздел 14.1.


```{r Поиск нужного показателя}
series_info %>% 
  filter(str_detect(fullname, 'розн')) %>% 
  select(fullname, tsname, unit)
```


При указании имени показателя загружается вся таблица, в которой он содержится.

```{r Загрузка ряда}
retail <- sophisthse('RTRD_M')
head(retail)
```


Посмотреть описание загруженных данных:

```{r Метаданные}
sophisthse_metadata(retail)

```


Полученный объект имеет тип многомерного временного ряда (`mts`) и матрицы (`matrix`).

```{r Тип объекта}
class(retail)
```

Извлечь нужный столбец можно по индексу. Рекомендуем использовать имена столбцов, а не номера, чтобы избежать ошибок при изменении числа столбцов в таблице.

```{r Извлечение столбца}

# Извлечение столбца
rtrd <- retail[, 'RTRD_M']

# Тип объекта для одномерного ряда
class(rtrd)

# Вывод значений
rtrd %>% head(36)

```

Таблица даже с единственным столбцом имеет тип многомерного ряда, поэтому может потребоваться "извлечь" оттуда столбец по индексу, чтобы с ним могли работать функции для прогнозирования и визуализации.

В начале ряда есть пропущенные значения. Чтобы удалить их, отберем наблюдения начиная с января 1995 года

```{r Отбор наблюдений}
rtrd <- rtrd %>%
  window(start = c(1995, 1))
```


# Анализ временного ряда

## Визуализация

Для построения графиков нам потребуются подписи для заголовка и осей. Их можно задать вручную, но можно и извлечь из метаданных ряда.

```{r Подписи для графика из метаданных ряда}
# Метка и единица измерения
rtrd_info <- sophisthse_metadata(retail) %>%
  filter(tsname == 'RTRD_M') %>%
  select(fullname, unit)

rtrd_label <- rtrd_info$fullname
rtrd_unit <- rtrd_info$unit
```

Функции базовой графики R могут работать с временными рядами `ts` непосредственно. Для визуализации временного ряда средствами `ggplot2` необходимо использовать функцию `autoplot()` пакета `forecast`. В результате получается объект, с которым можно продолжить работу стандартными средствами `ggplot2`.

```{r Визуализация}
autoplot(rtrd) +
  labs(y = rtrd_unit, x = NULL,
       title = rtrd_label) +
  geom_line(color = 'lightSkyblue')
```

Справку по использованию функции можно получить командой: `?autoplot.ts` или [онлайн](https://www.rdocumentation.org/packages/forecast/versions/8.1/topics/autolayer.mts).


## Классическая сезонная декомпозиция

Декомпозиция временного ряда позволяет выделить отдельные его компоненты - тренд, сезонность и нерегулярные изменения (остаток). 

Форма графика временного ряда позволяет предположить наличие тренда и сезонных колебаний мультипликативного типа.

Вначале воспользуемся встроенной функцией R - `decompose()`, реализующей метод классической декомпозиции на основе скользящего среднего. Визуализировать результаты можно с помощью функции `autoplot()`

```{r Классическая декомпозиция}

rtrd_d <- rtrd %>% 
  decompose(type = 'multiplicative')

autoplot(rtrd_d) +
  labs(title = 'Компоненты временного ряда (классическая декомпозиция)',
       x = NULL)

```

Результат декомпозиции имеет множество применений, например:

 - Легче сравнивать временные ряды, если исключить сезонные изменения.  
 - Легче выявлять нерегулярные изменения, не укладывающиеся в регулярные сезонные колебания.  
 - Можно скомбинировать компоненты, чтобы получить прогноз.  
 - После исключения сезонности и/или тренда из временного ряда результат можно описать с помощью более простой модели. Получив прогноз с помощью более простой модели, можно "вернуть" исключенные компоненты.  
 - Данные о сезонности гораздо более устойчивы, чем данные о тренде. Это может быть полезно при прогнозировании в кризисный период: сезонность сохраняется, а направление тренда резко изменяется из-за спада в экономике.  

Для извлечения компонентов ряда можно использовать их имена (`x` - исходный ряд, `seasonal` и `trend` - закономерные компоненты, `random` - остаток):

```{r Компоненты объекта при использовании классической декомпозиции}
names(rtrd_d)
```

Однако удобнее пользоваться специальными функциями пакета `forecast`:

```{r Извлечение компонентов ряда при помощи функций}

# Сезонные индексы
rtrd_d %>% seasonal() %>% head(12) %>% round(1)

# Тренд-циклическая компонента
rtrd_d %>% trendcycle() %>% head(12) %>% round(1)

# Остаток
rtrd_d %>% remainder() %>% head(12) %>% round(1)
```


Рассмотрим отдельно компоненты ряда. Для сравнения, будем изображать компоненты поверх исходного ряда

**Тренд**

```{r Тренд}
autoplot(rtrd, series = 'Оригинал') +
  autolayer(trendcycle(rtrd_d), series = 'Тренд') +
  labs(color = NULL, x = NULL, 
       y = rtrd_unit, title = rtrd_label) +
  scale_color_manual(values = c('lightskyblue', 'red')) +
  scale_x_continuous(minor_breaks = start(rtrd):end(rtrd))

```

Обратим внимание на то, что линия тренда короче исходного ряда. Это вызвано тем, что функция `decompose()` использует для выделения тренда скользящее среднее с окном, равным частоте временного ряда (12). В результате, по 6 периодов в начале и в конце ряда теряются, т.к. скользящее окно усреднения выходит в эти периоды за пределы данных и среднее не может быть вычислено.

На графике виден спад во время кризисов 2008 и 2015 года.

**Сезонный компонент**

```{r Сезонный компонент}
autoplot(seasonal(rtrd_d)) +
  labs(y = NULL, x = NULL,
       title = 'Сезонные коэффициенты') +
  scale_x_continuous(minor_breaks = start(rtrd):end(rtrd))

```

В методе классической декомпозиции сезонные коэффициенты получаются с помощью усреднения наблюдений для одноименных месяцев после удаления тренда, поэтому наборы сезонных коэффициентов для всех лет одинаковы.

**Модель ряда**

Модель ряда получается путем сочетания выделенных закономерных компонентов. Сравним результат с исходными данными.

```{r Модель ряда}
autoplot(rtrd, series = 'Оригинал') +
  autolayer(trendcycle(rtrd_d) * seasonal(rtrd_d),
            series = 'Модель') + 
  scale_colour_manual(values = c('dodgerblue', 'lightskyblue')) +
  labs(y = NULL, color = NULL, x = NULL,
       title = rtrd_label)
```

Результат близок к оригиналу, однако виды расхождения. Эти расхождения - **остатки**, или ошибки модели. Их также называют нерегулярным (случайным) компонентом ряда.

**Остатки**

```{r Нерегулярный компонент}
autoplot(remainder(rtrd_d)) +
  labs(y = NULL, x = NULL,
       title = 'Нерегулярный компонент ряда') +
  scale_x_continuous(minor_breaks = start(rtrd):end(rtrd))
```

Заметны регулярные колебания остатков, следовательно, закономерные компоненты исключены не полностью. Это - следствие того, что на протяжении выбранного для анализа периода величина сезонных коэффициентов менялась, но классическая декомпозиция не позволила этого учесть. Следовательно, необходимо использовать другой метод и/или сократить количество наблюдений временного ряда.



## Сезонная корректировка ряда

Сезонная корректировка ряда позволяет исключить влияние сезонных колебаний. Это облегчает анализ краткосрочных изменений ряда, которые иначе не видны из-за сезонности. Для выполнения сезонной корректировки в R можно использовать функцию `forecast::seasadj()`. Эта функция принимает в качестве аргумента объект, созданный одной из функций для декомпозиции.

```{r Сезонная корректировка}
rtrd_adj <- seasadj(rtrd_d)


autoplot(rtrd, series = 'Оригинал') +
  autolayer(trendcycle(rtrd_d), series = 'Тренд') +
  autolayer(rtrd_adj, series = 'СС ряд') + 
  scale_colour_manual(values = c('lightskyblue', 'brown', 'red')) +
  labs(y = NULL, color = NULL, x = NULL, 
       title = rtrd_label) +
  scale_x_continuous(minor_breaks = start(rtrd):end(rtrd))

```

В отличие от сильно сглаженной линии тренда, график сезонно-скорректированный ряд содержит случайные колебания уровня. Наш ряд имеет мультипликативную структуру, поэтому его модель может быть описана формулой:

$$ y = T \cdot S \cdot E, $$

где $T$ - тренд, $S$ - сезонный коэффициент, $E$ - случайная (нерегулярная) составляющая, или ошибка, $y$ - наблюдаемое значение ряда.

Тренд - это только компонент $T$, а ряд с исключенной сезонностью получается с помощью деления:

$$ A = \frac{y}{S} = T \cdot E. $$

В отличие от тренда, временной ряд с удаленной сезонностью содержит случайную составляющую $E$.


Аналогичного результата можно добиться и с помощью непосредственного деления исходного ряда на сезонные коэффициенты:

```{r Сезонная корректировка вручную}

autoplot(rtrd, series = 'Оригинал') +
  autolayer(trendcycle(rtrd_d), series = 'Тренд') +
  autolayer(rtrd_adj, series = 'СС ряд') +
  autolayer(rtrd/seasonal(rtrd_d), series = 'СС ряд, расчет') + 
  scale_colour_manual(values = c('lightskyblue', 'brown', 'orange', 'red')) +
  labs(y = NULL, color = NULL, x = NULL, 
       title = rtrd_label) +
  scale_x_continuous(minor_breaks = start(rtrd):end(rtrd))

```

Ряд с исключенной сезонностью содержит значения во всех периодах, т.к. для его вычисления используются непосредственно значения исходного ряда и сезонные коэффициенты. Сезонные коэффициенты - одни и те же для всех лет временного ряда, поэтому пустых периодов данных нет.


## Исключение тренда

Подобным же образом, можно удалить из ряда тренд, чтобы облегчить анализ изменений сезонного цикла.


```{r Удаление тренда}
rtrd_detrended <- rtrd/trendcycle(rtrd_d)

autoplot(rtrd_detrended) +
  labs(y = NULL, color = NULL, x = NULL, 
       title = 'Ряд с удаленным трендом') +
  scale_x_continuous(minor_breaks = start(rtrd):end(rtrd))

```


В пакете `forecast` имеется функция для визуализации отличий сезонных колебаний в разные годы - `ggseasonplot()`. В зависимости от задачи, более наглядным может оказаться применение этой функции к ряду с удаленным трендом.

```{r График сезонных циклов}

# Исходный ряд
rtrd %>%
  window(start = 2008) %>%
  ggseasonplot() +
  labs(title = 'Сезонный график (исходный ряд)')

# Ряд с удаленным трендом
rtrd_detrended %>%
  window(start = 2008) %>%
  ggseasonplot() +
  labs(title = 'Сезонный график (ряд с удаленным трендом)')

```




## STL-декомпозиция

Теперь выполним декомпозицию, используя функцию `forecast::stl()` (*Seasonal and Trend decomposition using Loess*). Данная функция также выделяет тренд с помощью сглаживания, но использует вместо скользящего среднего метод локальной регрессии - LOESS. Это позволяет исключить  потерю данных на концах ряда. Кроме того, метод более устойчив к выбросам в данных ряда. 

Недостатком этого подхода является поддержка сезонности только аддитивного типа. Большинство экономических временных рядов - мультипликативные. 

Для решения этой проблемы можно либо разрешить сезонным компонентам ряда постепенно меняться (используя параметр `s.window` функции `stl()`), либо преобразовать данные, чтобы превратить мультипликативный характер сезонности в аддитивный.

### Изменяющиеся сезонные коэффициенты

Обязательный параметр `s.window` функции `stl()` задает ширину окна для сглаживания ряда методом LOESS при извлечении сезонного компонента. Значение параметра должно быть нечетным и не менее 7. Также можно задать `s.window = 'periodic'`, тогда набор сезонных коэффициентов будет одним и тем же для всех лет.

```{r Влияние ширины окна сглаживания на сезонные индексы}

# Ширина окна сглаживания w задается в цикле
for (w in list(7, 15, 29, 49, 'periodic')) {
  p <- autoplot(seasonal(stl(rtrd, s.window = w))) +
    labs(title = str_c('s.window = ', w),
         x = NULL, y = 'Сезонный индекс')
  print(p)
}

```

Увеличение ширины окна сглаживания снижает скорость изменения сезонного компонента, однако это приводит к появлению сезонных колебаний в остатках модели.

```{r Влияние ширины окна сглаживания на остатки}

# Ширина окна сглаживания w задается в цикле
for (w in list(7, 15, 29, 49, 'periodic')) {
  p <- autoplot(remainder(stl(rtrd, s.window = w))) +
    labs(title = str_c('s.window = ', w),
         x = NULL, y = 'Остаток')
  print(p)
}
```

В данном случае ряд изменяется очень быстро, поэтому выберем минимальную ширину окна для сглаживания сезонных индексов - 7.

```{r STL-декомпозиция с изменяющимися сезонными коэффициентами}
rtrd_stl <- stl(rtrd, s.window = 7)
```

Как и в случае с классической декомпозицией, отдельные компоненты ряда можно извлечь при помощи функций `seasonal()`, `trendcycle()` и `remainder()`.


```{r График нерегулярного компонента}

rtrd_stl %>%
  remainder() %>%
  autoplot() +
    labs(title = 'Покупательские подвиги во время кризисов',
         x = NULL, y = 'Остаток') +
    scale_x_continuous(minor_breaks = start(rtrd):end(rtrd))

```


Сезонная корректировка ряда позволяет увидеть эти пики в масштабе исходных данных.

```{r Сезонная корректировка ряда методом STL}

autoplot(rtrd, series = 'Оригинал') +
  autolayer(seasadj(rtrd_stl), series = 'СС ряд') +
  scale_colour_manual(values = c('lightskyblue', 'brown')) +
  labs(y = NULL, title = rtrd_label, color = NULL) +
  scale_x_continuous(minor_breaks = start(rtrd):end(rtrd))
```

### Логарифмирование

Другой способ обойти проблему мультипликативной сезонности - преобразование данных. При логарифмировании произведение компонент ряда заменяется на сумму логарифмов:

$$ y = T \cdot S \cdot E \Rightarrow  \log y = \log T + \log S + \log E $$

```{r График ряда после логарифмирования}
autoplot(log10(rtrd)) +
  labs(title = 'Десятичный логарифм оборота розничной торговли',
       x = NULL) +
  geom_line(color = 'darkgray')
```


Аддитивная лучше подходит к преобразованным данным. 

Данный подход неудобен тем, что для визуализации компонентов в исходном масштабе необходимо обратное преобразование - вычисление показательной функции. Также этот метод не применим, когда в исходных данных содержатся нули.

```{r STL-декомпозиция логарифмированного ряда}
log_rtrd_stl <- rtrd %>% 
  log10() %>% 
  stl(s.window = 'periodic')

autoplot(log_rtrd_stl)
```

Чтобы сравнить модель ряда с исходными данными, необходимо выполнить обратное преобразование компонентов ряда - $10^x$.

```{r Сравнение оригинального ряда и модели}

rtrd_stl_fit <- 10^(trendcycle(log_rtrd_stl) + 
                    seasonal(log_rtrd_stl))

autoplot(rtrd, series = 'Оригинал') +
  autolayer(rtrd_stl_fit, series = 'Модель') + 
  scale_colour_manual(values = c('dodgerblue', 'lightskyblue')) +
  labs(y = NULL, color = NULL, x = NULL,
       title = rtrd_label)


```


### Преобразование Бокса-Кокса

Помимо логарифмирования, можно применять и другие преобразования ряда, чтобы уменьшить зависимость амплитуды колебаний от уровня ряда. Например, применяются **степенные преобразования** (**power transformations**):  

$$w_t = y_t ^ {p},$$


где $$p \in \{\frac{1}{2}, \frac{1}{3}, -1 \}. $$

Бокс и Кокс предложили удобный способ описания целого семейства преобразований, включающего степенные преобразования и логарифмирование с помощью параметра $\lambda$. 

**Преобразование Бокса-Кокса** (**Box-Cox transformation**) задается следующим образом:

$$
 w_t = 
  \begin{cases} 
   \log{y} &   \text{при } \lambda = 0 \\
   (y_t^\lambda - 1) / \lambda & \text{иначе.}
  \end{cases}
$$

Логарфм используется натуральный.

Для преобразования временных рядов в R имеется функция `forecast::BoxCox()`.

```{r Преобразования Бокса-Кокса}
# Параметр преобразования изменяется в цикле
for (lambda in c(-1, -0.5, -0.25, 0, 0.25, 0.5, 1)) {
  p <- autoplot(BoxCox(rtrd, lambda)) +
    labs(title = str_c('lambda = ', lambda),
         x = NULL, y = NULL) +
    geom_line(color = 'darkgray')
  print(p)
  
}



```

Аналогичный пример, демонстрирующий влияние параметра $\lambda$, можно посмотреть [здесь](http://www.otexts.org/sites/default/files/fpp/images/telec.gif)

Для автоматического подбора $\lambda$, при котором преобразованный ряд наиболее близок к аддитивной сезонной модели, можно использовать функцию `forecast::BoxCox.lambda()`. О применяемых методах подбора параметра $\lambda$ можно прочитать в справке.

```{r Автоматический подбор параметра преобразования Бокса-Кокса}

best_lambda <- BoxCox.lambda(rtrd)

autoplot(BoxCox(rtrd, best_lambda)) + 
    labs(title = paste('lambda = ', round(best_lambda, 2)),
         x = NULL, y = NULL)

```

Полученное в результате подбора значение параметра можно использовать в качестве ориентира, поскольку дробные значения $\lambda$ затрудняют интерпретацию данных. Например, $\lambda = 0.42$ лучше заменить на $\lambda = 0.5$ (квадратный корень).

В данном случае значение параметра $\lambda$ близко к нулю, следовательно для преобразования лучше всего применять логарифмирование.


Чтобы перейти от преобразованных данных назад к исходным, необходимо применить обратное преобразование (**back-transform**). Математически **обратное преобразование Бокса-Кокса** (**reverse Box-Cox transformation**) задается следующим образом:

$$
 y_t = 
  \begin{cases} 
   \exp(w_t) &   \text{при } \lambda = 0 \\
   (\lambda w_t + 1) ^ \frac{1}{\lambda}  & \text{иначе.}
  \end{cases}
$$

В R для обратного преобразования Бокса-Кокса используется функция `forecast::InvBoxCox()`.

При использовании преобразований Бокса-Кокса помните о следующих его особенностях:

- При наличии во временном ряде отрицательных или нулевых значений преобразование невозможно. Однако можно прибавить константу ко всем значения ряда, чтобы исключить отрицательные значения.
- Выбирайте легко интерпретируемые значения $\lambda$ (0.37 -> 0.33, или кубический корень).
- Методы прогнозирования слабо чувствительны к изменению параметра $\lambda$
- Часто преобразование не требуется
- Преобразование иногда практически не изменяет точечный прогноз, но сильно влияет на доверительные интервалы для прогноза.

